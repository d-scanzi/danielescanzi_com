{"title":"Daniele's useful R code for EEG data analysis","markdown":{"yaml":{"title":"Daniele's useful R code for EEG data analysis"},"headingText":"From eegUtils to tidy data","containsRefs":false,"markdown":"\n\nThe idea for this document comes from [Makoto's useful EEGLAB code](https://sccn.ucsd.edu/wiki/Makoto's_useful_EEGLAB_code). The intention behind this document is to have a place to store code that I produce while working on my projects and that I find useful. Besides being a somewhat unstructured place to save code that I could use in the future, this document might be helpful for researchers interested in using R to analyse EEG data.\n\n\n[eegUtils](https://craddm.github.io/eegUtils/articles/eegUtils.html) is an R package developed by Matt Craddock that allows you to analyse EEG data in R. Currently, I pre-process data in Matlab with [EEGLAB](https://eeglab.org/). Thus, I use `eegUtils` to load pre-processed and epoched data in R to conduct statistical analysis. Although `eegUils` is a handy package, and I love that I can easily use R to do EEG data analysis and plot scalp topographies, some aspects of this package do not align with my preferences. Specifically:\n\n-   The voltage data is stored in wide format, with one column for each electrode\n-   Time information is stored separately from the EEG signal information\n\nConsequently, I find it easier to extract the data I care about (voltage, electrode names and time values) and store those in a long-format `tibble`. As I do this often, I wrote a function for this.\n\n*Note that some of the functions you find in the other paragraphs require the data extracted from `eegUtils` using this function. I highlighted when this is the case*\n\n```{r}\n#| eval: false\n\ntidy_signal_from_eegUtils <- function(eegUtilsDataset) {\n  \n  tidy_data <- eegUtilsDataset %>% \n  # Add time column\n  dplyr::mutate(time = signal[[\"timings\"]][[\"time\"]]) %>% \n  # Reorganise the dataset \n  dplyr::pivot_longer(cols      = !time,\n               names_to  = \"electrode\",\n               values_to = \"volt\") \n  \n  return(tidy_data)\n  }\n\n```\n\n## Computing ERP amplitudes\n\nThe following code presupposes that the EEG data is stored in a `dataframe` or `tibble` in long format. The dataset must contain three columns:\n\n-   *time*: time in ms for each sample\n-   *electrode*: electrode name\n-   *volt*: the voltage value for each sample\n\nTo create such a dataset from a file loaded through [eegUtils](https://craddm.github.io/eegUtils/articles/eegUtils.html) see working with eegUtils.\n\nThere are two common ways to compute an ERP amplitude: average amplitude and peak amplitude. Average amplitude involves averaging the microvolts of a signal over a specified time range (where the ERP is expected). The peak amplitude consists in finding the maximum value of a peak or the minimum value of a trough. Peaks and troughs are the ERPs. Remember that peak amplitudes have drawbacks, and the average amplitude should be preferred.\n\nHere are some functions to compute both values. I also provide a wrapper function that extract both average and peak amplitudes.\n\n### Extracting time bins\n\nFor flexibility, we need a function to select the signal within a specific time bin. We will use this function to allow the user to define the time range where to extract the average and peak values.\n\n```{r}\n#| eval: false\n\n# Function to extract the signal in a defined time bin. The time bin \n# can be specified as:\n#     - c(min, max): with the minimum and max time in ms\n#     - max: only the maximum value in ms\nextract_bin_signal <- function(eegDataset, bin = NULL) {\n    # Time bin must be provided\n    if (is.null(bin)) {\n        stop(\"Time bin is missing.\")\n    }\n    # If min and max provided\n    if (length(bin == 2)) {\n        binned <- eegDataset %>% \n          # Group by electrode, so to extract signal for each electrode independently\n          dplyr::group_by(electrode) %>% \n          # Select the requested time range\n          dplyr::filter(time >= bin[1] & time <= bin[2]) %>% \n          dplyr::ungroup()\n    # If only the max is provided\n    } else if (length(bin == 1)) {\n        binned <- eegDataset %>%\n          # Group by electrode, so to extract signal for each electrode independently\n          dplyr::group_by(electrode) %>% \n          # Select the requested time range - from first time point to requested max\n          dplyr::filter(time <= bin) %>% \n          dplyr::ungroup()\n    # If the time range is not a vector of one or two values throw an error\n    } else {\n        stop(\"Bin must be a vector of one or two values\")\n    }\n}\n```\n\n### Compute average amplitude\n\nTo extract the average amplitude, we can simply compute the mean of the voltage for each electrode.\n\n```{r}\n#| eval: false\n\n# Define a function to find the average amplitude\n# Note that this function requires that the dataset contains the electrode and \n# volt columns \nfind_average_amplitudes <- function(eegDataset) {\n    # compute average amplitude for each electrode\n    return(eegDataset %>%\n               group_by(electrode) %>% \n               summarise(average_amplitude = mean(volt)) %>% \n               ungroup()\n    )\n    \n}\n```\n\n### Compute the peak amplitude\n\nThis function is quite complex. The complexity is driven by the fact that an ERP can be any positive or negative deflection in an EEG signal. For a positive deflection, we want to find its maximum value. For a negative deflection, we want to find the minimum value. To do this, we use the `findpeaks` function of the [pracma](https://cran.r-project.org/web/packages/pracma/index.html) package. As this function finds only the local peaks of a signal, to find the local minima we will multiply the signal by `-1` to invert peaks and troughs.\n\nNote that this function is quite flexible as the user is able to select whether to extract only peak, only troughs or both amplitudes. Importantly, as a signal might have only peaks and not troughs, or vice versa, if one or the other is not found, an `NA` is produced.\n\n```{r}\n#|eval: false\n\nfind_peak_amplitudes <- function(eegDataset, peaks = TRUE, valleys = TRUE) {\n    \n    # Split eeg dataset into list of dataframes, each one containing the signal\n    # for one channel\n    data_list <- eegDataset %>% \n        dplyr::group_by(electrode) %>% \n        dplyr::group_split()\n    \n    # Extract only the signal to pass to findpeaks\n    data_volt       <- lapply(data_list, function(x) x[[\"volt\"]])\n    # Extract the electrode information to use later\n    list_electrodes <- sapply(data_list, function(x) x[[\"electrode\"]][[1]])\n    # Extract time vectors \n    list_times      <- sapply(data_list, function(x) x[[\"time\"]]) \n    \n    \n    ## If both peaks and valleys are requested\n    if (peaks & valleys) {\n        \n        # Find peak amplitudes, peak_idx, [start:stop]\n        peaks_info   <- sapply(data_volt, pracma::findpeaks, npeaks = 1)\n        # Find valleys ampl, peak_idx, [start:stop] - Here we use the function\n        # findpeaks as above. Thus, we need to invert the signal so that valleys\n        # become peaks and will be detected. Because of this, later we will \n        # invert the sign of the signal to revert to the original value\n        valleys_info <- sapply(lapply(data_volt, function(x) x*-1), pracma::findpeaks, npeaks = 1)\n        \n        # NOTE: peaks_info and valleys_info work well when the signal has peaks\n        # and valleys. However, as soon as a signal does not have one of those,\n        # then `findpeaks` returns NULL and `sapply` fails to produce a matrix and \n        # defaults to a list. This, in turn, produce an error in extracting the \n        # peak times. As a NULL list as no dimension, when we call \n        # `[[peaks_info[[2, x]]` (see later), we get an error. To avoid this, we\n        # capture any NULL list, convert it into a matrix of [1 x 4] NA, and \n        # convert this into what sapply would produce (i.e. a matrix). The size\n        # of the matrix reflect the output of findpeaks when a peak is found.\n        \n        # If sapply produced a list - thus we have NULL nested lists\n        if (is.list(peaks_info)) { \n            # Change all NULL to a [1x4] matrix - the dimension follows what would\n            # be the output of `findpeaks`\n            peaks_info_no_null <- lapply(peaks_info, \n                                         function(x) if(is.null(x)) matrix(rep(NA_real_, 4), nrow = 1) else x)\n            # Matrix the results through sapply\n            peaks_info <- sapply(peaks_info_no_null, function(x) x)\n        }\n        \n        # Repeat the same with valleys_info\n        if (is.list(valleys_info)) { \n            # Change all NULL to a [1x4] matrix - the dimension follows what would\n            # be the output of `findpeaks`\n            valleys_info_no_null <- lapply(valleys_info, \n                                         function(x) if(is.null(x)) matrix(rep(NA_real_, 4), nrow = 1) else x)\n            # Matrix the results through sapply\n            valleys_info <- sapply(valleys_info_no_null, function(x) x)\n        }\n        \n        # Extract peak times\n        peaks_time   <- sapply(1:ncol(list_times), \n                               function(x) if(is.na(peaks_info[[2, x]])) NA_real_ else list_times[[peaks_info[[2, x]], x]])\n        valleys_time <- sapply(1:ncol(list_times), \n                               function(x) if(is.na(valleys_info[[2, x]])) NA_real_ else list_times[[valleys_info[[2, x]], x]])\n        \n        # Store the results in a handy tibble\n        peaks_amplitudes <- as_tibble(cbind(\n            \"electrode\"  = list_electrodes,\n            \"peak\"        = peaks_info[1, ],\n            \"valley\"      = -valleys_info[1, ], # Revert the sign for the valleys\n            \"peak_time\"   = peaks_time,\n            \"valley_time\" = valleys_time\n            )\n        )\n    # If only peaks are requested\n    } else if (peaks & !valleys) {\n      # Find peaks ampl, peak_idx, [start:stop]\n        peaks_info   <- sapply(data_volt, pracma::findpeaks, npeaks = 1)\n        \n        # If sapply produced a list - thus we have NULL nested lists\n        if (is.list(peaks_info)) { \n            # Change all NULL to a [1x4] matrix - the dimension follows what would\n            # be the output of `findpeaks`\n            peaks_info_no_null <- lapply(peaks_info, \n                                         function(x) if(is.null(x)) matrix(rep(NA_real_, 4), nrow = 1) else x)\n            # Matrix the results through sapply\n            peaks_info <- sapply(peaks_info_no_null, function(x) x)\n        }\n        \n        # Extract times\n        peaks_time   <- sapply(1:ncol(list_times), \n                               function(x) if(is.na(peaks_info[[2, x]])) NA_real_ else list_times[[peaks_info[[2, x]], x]])\n        # Store the results in a handy tibble\n        peaks_amplitudes <- as_tibble(cbind(\n            \"electrode\"  = list_electrodes,\n            \"peak\"        = peaks_info[1, ],\n            \"peak_time\"   = peaks_time\n            )\n        )\n    # If only troughs are requested\n    } else if (!peaks & valleys) {\n        # Find valleys ampl, peak_idx, [start:stop] - Here we use the function\n        # findpeaks as above. Thus, we need to invert the signal so that valleys\n        # become peaks and will be detected. Because of this, later we will \n        # invert the sign of signal to revert to the original value\n        valleys_info <- sapply(lapply(data_volt, function(x) x*-1), pracma::findpeaks, npeaks = 1)\n        \n        # Repeat the same with valleys_info\n        if (is.list(valleys_info)) { \n            # Change all NULL to a [1x4] matrix - the dimension follows what would\n            # be the output of `findpeaks`\n            valleys_info_no_null <- lapply(valleys_info, \n                                         function(x) if(is.null(x)) matrix(rep(NA_real_, 4), nrow = 1) else x)\n            # Matrix the results through sapply\n            valleys_info <- sapply(valleys_info_no_null, function(x) x)\n        }\n        \n        # Extract times\n        valleys_time <- sapply(1:ncol(list_times), \n                               function(x) if(is.na(valleys_info[[2, x]])) NA_real_ else list_times[[valleys_info[[2, x]], x]])\n        # Store the results in a handy tibble\n        peaks_amplitudes <- as_tibble(cbind(\n            \"electrode\"  = list_electrodes,\n            \"valley\"      = -valleys_info[1, ], # Revert the sign for the valleys\n            \"valley_time\" = valleys_time\n            )\n        )\n    # if peaks and valleys argument are set both to FALSE\n    } else {\n        stop(\"At least one argument between 'peaks' and 'valleys' must be TRUE\")\n    }\n    \n    # Return the result tibble\n    return(peaks_amplitudes)\n    \n}\n\n```\n\n### Wrapper function for ERP amplitudes\n\nThe above functions can be used separately. However, it could be handy to have a wrapper function that allows the user to compute both peak and average amplitudes simultaneously. Again, the following function is highly flexible, allowing the user to:\n\n-   Define a time bin where to compute the amplitude measures. If no bin is provided, the whole signal is used\n-   Selecting whether to extract the only peak, only troughs, only averages amplitude or any combination of those\n\n```{r}\n#| eval: false\n\n# We then put all together in a single function\nfind_erp_amplitudes <- function(eegDataset, bin = NULL, peaks = TRUE, valleys = TRUE, avg = TRUE) {\n    \n    # If a time bin is provided, call extract_bin_signal (see above) to extract \n    # only the signal wirthin the requested time range\n    if (!is.null(bin)) {\n        # Extract the signal in the defined bin\n        binned_signal <- extract_bin_signal(eegDataset, bin = bin)\n    # If no time bin is provided, use the whole signal\n    } else {\n        binned_signal <- eegDataset\n    }\n    \n    # If peaks, troughs and average amplitude are requested\n    if ((peaks | valleys) & avg) {\n        # Extract peak and average amplitudes\n        peak_amps     <- find_peak_amplitudes(binned_signal, peaks = peaks, valleys = valleys)\n        avrg_amps     <- find_average_amplitudes(binned_signal)\n    \n        amplitudes    <- merge(peak_amps, avrg_amps)\n    # If only peak and troughs amplitudes are requested\n    } else if ((peaks | valleys) & !avg) {\n        amplitudes <- find_peak_amplitudes(binned_signal, peaks = peaks, valleys = valleys)\n    # If only troughs and average amplitude are requested\n    } else if (!(peaks | valleys) & avg) {\n        amplitudes <- find_average_amplitudes(binned_signal)\n    # If every amplitude argument is set to FALSE\n    } else {\n        stop(\"You need to provide at least one argument between peaks, valleys or avg\")\n    }\n\n    return(amplitudes)\n}\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"daniele_useful_code_r_eeg.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":{"dark":["cyborg","../../mystyles.scss"],"light":["cyborg","../../cyborg_light.scss"]},"title":"Daniele's useful R code for EEG data analysis"},"extensions":{"book":{"multiFile":true}}}}}