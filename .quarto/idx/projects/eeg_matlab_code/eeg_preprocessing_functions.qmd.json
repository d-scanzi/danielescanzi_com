{"title":"EEG preprocessing functions","markdown":{"yaml":{"title":"EEG preprocessing functions"},"headingText":"Counting triggers","containsRefs":false,"markdown":"\n\nA collection of functions and code-snippets useful for EEG preprocessing with EEGLAB (Matlab). Note, I distribute these functions under the GNU General Public License. I removed the statement to slim the code and the page. However, if you use or modify any of these functions in your projects, please add the GNU licence statement at the end of the function help. You can find the statement at the end of this page.\n\n\nThis function takes an EEGLAB *EEG* structure and returns a cell array containing the number of triggers (aka events) divided for each trigger type. I use it as a sanity check to ensure that my data does not contain missing triggers and that the participant completed the correct number of trials/blocks.\n\n```octave\n% nTrig = count_triggers(EEG)\n%\n%    Count the number of unique triggers contained in the EEG.event \n%    structure.\n%\n% In:\n%    EEG   - An EEGLAB data structure\n%\n% Out:\n%    nTrig - Cell array containing the unique trigger names and how many\n%            times they occur in the recording.\n\n% Author: Daniele Scanzi\n\nfunction nTrig = count_triggers(EEG)\n\n    % Check that event structure is in EEG structure\n    if ~isfield(EEG, \"event\")\n        error(\"Cannot find event structure. Is EEG an EEGLAB structure?\")\n    end\n    \n    % Find unique events\n    nTrig = unique({EEG.event.type})';\n    if isempty(nTrig)\n        error(\"Cannot find any events in the event structure. Do you need to load them?\")\n    end\n\n    % Create cell array storing name of event and their number\n    for iEvent = 1:size(nTrig,1)\n        nTrig{iEvent, 2} = sum(strcmp({EEG.event.type}, nTrig{iEvent, 1}));\n    end\n\nend\n```\n\n## Add extra trigger information\n\nThis function is useful if you have triggers represented as codes (eg. *T100*) and you would like to add their meaning in the EEG.event structure. However, you can add any other information.\n\n```octave\n% EEG = add_trigger_info(EEG, trigInfo, varargin)\n%\n%    Add extra information to the EEG.event structure. It is useful to add\n%    trigger information for each trigger. For instance, you can add the\n%    meaning of each trigger if trigger codes have been used.\n%\n% In:\n%    EEG      - An EEGLAB data structure\n%    trigInfo - Cell array of size NxM. N should reflect the number of\n%               triggers for which extra information should be added. M\n%               should reflect the nuber of extra information to add. M new\n%               columns will be added to the EEG.event structure. M must be\n%               at least 2, where the first column should contain the\n%               names of the triggers (one for each row) and the second\n%               column contains the information to add. For instance, if\n%               you have three triggers and you want to add their meaning,\n%               you could pass a cell array such as:\n%               {'T100' 'start_recording'; \n%                'T150' 'pause_recording';\n%                'T200' 'stop_recording'}\n%\n% Optional:\n%     fieldName - Cell array containing the names of the new columns to add\n%                 to the EEG.event structure. The cell array should have\n%                 size of 1xM, where M is the number of the extra\n%                 information columns to add. M must match the number of\n%                 columns of trigInfo. If no names are provided, the new\n%                 columns will be named 'X1', 'X2',..., 'XM'\n%\n% Out:\n%    EEG        - Modified copy of the EEG structure\n\n% Author: Daniele Scanzi\n\nfunction EEG = add_trigger_info(EEG, trigInfo, varargin)\n\n    p = inputParser;\n    \n    % Mandatory\n    addRequired(p, 'EEG', @isstruct);     % EEG structure\n    addRequired(p, 'trigInfo', @iscell);  % Cell array containing tirgger info\n    \n    % Optional\n    addParameter(p, 'fieldName', [], @iscell);         % Name/s to provide to the fields to add\n    \n    % Parse user input\n    parse(p, EEG, trigInfo, varargin{:});\n\n    EEG = p.Results.EEG;\n    triggInfo   = p.Results.trigInfo;\n    fieldName   = p.Results.fieldName;\n\n    %% Checks\n   \n   if size(trigInfo, 2) <= 1\n       error('triggerInfo should be a cell array with at least two columns: Trigger names - New field1 \\n');\n   end\n\n   % Create names for field if not provided, check otherwise\n   if isempty(fieldName)\n       fieldName = cell(size(trigInfo, 2) - 1, 1);\n       for iField = 1:( size(trigInfo, 2) - 1 )\n           fieldName{iField, 1} = strcat('X', num2str(iField));\n       end\n   else\n       if length(fieldName) ~= ( size(trigInfo, 2) - 1 )\n           error('fieldNames should match the number of new fields contained in trigInfo \\n');\n       end\n   end\n   \n   for iEvent = 1:length(EEG.event)\n       currentEvent       = EEG.event(iEvent).type;\n       currentTrigInfoIdx = find(strcmp(trigInfo(:, 1), currentEvent));\n\n       % Add info\n       for iInfo = 1:length(fieldName)\n           if isempty(currentTrigInfoIdx)\n               EEG.event(iEvent).(fieldName{iInfo}) = 'n/a';\n           else\n               EEG.event(iEvent).(fieldName{iInfo}) = trigInfo{currentTrigInfoIdx, iInfo+1};\n           end\n       end\n   end\nend\n\n```\n\n## Compute latencies with photosensor\n\nIn our current EEG setup, we have a [Brainproducts](https://www.brainproducts.com/) system where triggers are sent through a [triggerbox](https://www.brainproducts.com/solutions/triggerbox/). We also have a [photosensor](https://pressrelease.brainproducts.com/photosensor/), which allows us to detect with precision when a stimulus is presented on the screen. Unfortunately, we do not have the [StimTrack](https://www.brainproducts.com/solutions/stimtrak/) used to convert the photosensor data into triggers. So, we need to do this ourselves.\n\nThe photosensor data is stored as an extra channel in the EEG data. If the photosensor is set up to detect a switch from a dark to a light stimulus, then it creates a trace with a spike (NOTE: not a square wave) when the switch happens. The spike begins at the onset of the light stimulus and peaks just after that. \n\nI did not test this function with other systems, but I would assume it would work (grating that the photosensor records luminance and not just the change in luminance).\n\nBriefly, this function does the following:\n1. Detect the photosensor spikes onsets\n2. Add triggers at the detected onset latencies\n3. For each trigger, check whether there is an associated photosensor trigger, accounting for the fact that the photosensor could appear before or after the associated trigger. \n\nThe order of photosensor-trigger seems to depend on how the experiment is coded and reflects whether the trigger lags behind the stimulus or not. I'm still discussing this point with friends, but we don't have a conclusive explanation for this. Any insight on this is welcomed.\n\n```octave\n% [eventLatenciesInfo, EEG] = trigger_photo_latency(EEG, eventNames, varargin)\n%\n%         Align the recorded triggers to the onset times recorded by\n%         Brainproducts' photosensor. Conversion follows the procedure:\n%         1. Extract data from photosensor\n%         2. Find onset of spikes - spikes reflect changes in contrast\n%         3. Add found onsets to EEG.event structure in chronological order\n%         4. For eah trigger, find closest spike (within defined tolerance)\n%         5. Convert the original onset time of each trigger to its\n%            assciated spike onset time\n%\n% In:\n%    EEG        - An EEGLAB data structure\n%    eventNames - Cell array of strings represenitng the names of the\n%                 triggers to align\n%\n% Optional:\n%    photoTrigger       - Name to provide to the triggers representing the\n%                         photosensor event onsets. Default: 'photo'\n%    photoChannel       - Channel number (int) or channel name (string) of \n%                         the channel containing the photosensor data\n%    normalisePhotoData - Logical (true|false). Whether to normalise the \n%                         photosensor data prior to find the peaks. If true, \n%                         data is normalised in range [0,1]. Default: true\n%\n%    peakHeightThresh   - Minimum peak height for a photosensor spike to be\n%                         considered an event. This value is empirical and\n%                         it depends on multiple factors (eg. colour of the\n%                         photosensor stimulus). Can be useful to evoid \n%                         considering events changes in diplay contrast not\n%                         associated with the experiment (eg. experiment \n%                         window opening). Deafult: 0\n%    missedTrigTresh    - Maximum acceptable lag (in ms) between recorded \n%                         trigger and photosensor spike. If the lag is\n%                         higher than thism a warning is produced. This\n%                         often occurs if you try to align a trigger that\n%                         does not have an associated photosensor.\n%    modifyOriginal     - Logical (true|false). Whether to return a modified\n%                         copy of the EEG structure containin the\n%                         re-aligned events. Default: true\n%\n% Out:\n%    eventLatenciesInfo - Cell array containing delays information for each\n%                         trigger included in eventNames. Each row\n%                         represents a different trigger. Columns\n%                         represent: \n%                         1. Trigger name\n%                         2. Trigger idx in modified EEG.event structure\n%                         3. Array of delays (ms) for each trigger\n%                         4. Average delay (ms) for each trigger\n%    EEG                - Modified copy of the EEG structure where the \n%                         EEG.event structure now contains:\n%                         1. Photosensor events as triggers\n%                         2. Onset of triggers alligned with the\n%                            photosensor events\n\n% Author: Daniele Scanzi\n\nfunction [eventLatenciesInfo, EEG] = trigger_photo_latency(EEG, eventNames, varargin)\n    \n    % INPUTS\n    p = inputParser;\n    \n    % Mandatory\n    addRequired(p, 'EEG', @isstruct);      % EEG structure with EEG data\n    addRequired(p, 'eventNames', @iscellstr); % Signal matrix\n    \n    % Optional\n    addParameter(p, 'photoTrigger', 'photo', @ischar);       % Name of the trigger to add\n    addParameter(p, 'photoChannel', 64);                     % Channel containing the photosensor data\n    addParameter(p, 'normalisePhotoData', true, @islogical); % Whether to normalise the data or not\n    addParameter(p, 'peakHeightThresh', 0, @isnumeric);      % Minimum height to consider something a peak\n    addParameter(p, 'missedTrigTresh', 16, @isnumeric);      % Max delay (in ms) acceptable\n    addParameter(p, 'modifyOriginal', true, @islogical);     % Whether to modify the original EEG structure or not\n    \n    parse(p, EEG, eventNames, varargin{:});\n    \n    EEG                = p.Results.EEG;\n    eventNames         = p.Results.eventNames;\n    photoTrigger       = p.Results.photoTrigger;\n    photoChannel       = p.Results.photoChannel;\n    normalisePhotoData = p.Results.normalisePhotoData;\n    peakHeightThresh   = p.Results.peakHeightThresh;\n    missedTrigTresh    = p.Results.missedTrigTresh;\n    modifyOriginal     = p.Results.modifyOriginal;\n\n    %% MAIN FUNCTION\n\n    % Check that event structure is in EEG structure\n    if ~isfield(EEG, \"event\")\n        error(\"Cannot find event structure. Is EEG an EEGLAB structure?\")\n    end\n\n    % Check that provided events exist\n    for iEvent = 1:length(eventNames)\n        if ~any(strcmp({EEG.event.type}, eventNames{iEvent}))\n            error(\"Cannot find %s in EEG.event structure\", eventNames{iEvent})\n        end\n    end\n\n    % Check that data contains the channel requested\n    if isinteger(photoChannel)\n        if ~size(EEG.data, 1) < photoChannel\n            error(\"Channel %i out of bound of data size %i\", photoChannel, size(EEG.data, 1))\n        end\n    elseif ischar(photoChannel) || isstring(photoChannel)\n        if ~any(strcmp({EEG.chanlocs.labels}, photoChannel))\n            error(\"Channel %s not found\", photoChannel)\n        else\n            % find channel number and overwrite string\n            photoChannel = find(strcmp({EEG.chanlocs.labels}, photoChannel));\n        end\n    end\n\n    % The function should run even with epoched data, but this has not been\n    % tested yet. There are no many reasons for using this function with\n    % epoched data anyway\n    if ndims(EEG.data) > 2\n        warning(\"Function not tested with epoched data (or data with more \" + ...\n            \"than two dimensions in general\" )\n    end\n\n    % Extract photsensor data (account for possibility of data being\n    % epoched). Correct peaks so to find photosensor onset\n    photoData = EEG.data(photoChannel, :, :);\n    photoData = diff(photoData);\n    \n    if normalisePhotoData\n        photoData = normalize(photoData, 'range');\n    end\n\n    % Find peaKs\n    [~, peaksLocs] = findpeaks(photoData, 'MinPeakHeight', peakHeightThresh);\n\n    % Add peaks to the event structure data\n    fprintf(\"Adding photosensor events to EEG.event structure\")\n    % Add peaks to chanloc values\n    for iPeak = 1:length(peaksLocs)\n        EEG.event(end+1).latency = peaksLocs(iPeak);\n        EEG.event(end).type = photoTrigger;\n    end\n\n    % Reorder events by latency\n    EEG = eeg_checkset(EEG,'eventconsistency');\n\n    % First find triggers indices\n    eventLatenciesInfo = {length(eventNames), 4};\n    for iEvent = 1:length(eventNames)\n        eventLatenciesInfo{iEvent, 1} = eventNames{iEvent};\n        eventLatenciesInfo{iEvent, 2} = find(strcmp({EEG.event.type}, eventNames{iEvent}));\n    end\n    \n    % Compute event latencies finding the nearest photosensor event\n    for iEvent = 1:size(eventLatenciesInfo, 1)\n        % create arry to store latencies\n        currentLatencies = nan(length(eventLatenciesInfo{iEvent, 2}), 1);\n        for iTrig = 1:length(eventLatenciesInfo{iEvent, 2})\n\n            % Check previous event\n            previousTrigger = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)-1);\n            nextTrigger     = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)+1);\n            if strcmp({previousTrigger.type}, photoTrigger)\n                previousLatencyDiff = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency - EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)-1).latency;\n            else\n                % if there is no photosensor trigger before, set this diff\n                % tp -Inf\n                previousLatencyDiff = nan;\n            end\n\n            % Check next event\n            if strcmp({nextTrigger.type}, photoTrigger)\n                nextLatencyDiff = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)+1).latency - EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency;\n            else\n                % if there is no photosensor trigger before, set this diff\n                % tp -Inf\n                nextLatencyDiff = nan;\n            end\n\n            % Find minimum between the two\n            [currentMin, minIdx] = min([previousLatencyDiff nextLatencyDiff]);\n            if  currentMin > missedTrigTresh\n                warning(\"Possible missing triggers around trigger number %i. Event not included in latency calculation \\n\", eventLatenciesInfo{iEvent, 2}(iTrig));\n                currentLatencies(iTrig) = nan;\n            else\n                currentLatencies(iTrig) = currentMin;\n            end\n            \n            % Modify the original dataset event structure if requested\n            if modifyOriginal\n                if minIdx == 1\n                    EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency = previousTrigger.latency;\n                elseif minIdx == 2\n                    EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency = nextTrigger.latency;\n                end\n            end\n\n        end\n\n        % Compute average latency excluding missing triggers\n        currentLatencies = currentLatencies(~isnan(currentLatencies));\n        eventLatenciesInfo{iEvent, 3} = currentLatencies;\n        eventLatenciesInfo{iEvent, 4} = mean(currentLatencies);\n    end\n    EEG = eeg_checkset(EEG);\nend\n\n\n\n% Helper\nfunction isText(myVar)\n    isstring(myVar) || ischar(myVar);\nend\n```\n\n## GNU statement\n\n*This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.*\n \n*This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details (https://www.gnu.org/licenses).*\n","srcMarkdownNoYaml":"\n\nA collection of functions and code-snippets useful for EEG preprocessing with EEGLAB (Matlab). Note, I distribute these functions under the GNU General Public License. I removed the statement to slim the code and the page. However, if you use or modify any of these functions in your projects, please add the GNU licence statement at the end of the function help. You can find the statement at the end of this page.\n\n## Counting triggers\n\nThis function takes an EEGLAB *EEG* structure and returns a cell array containing the number of triggers (aka events) divided for each trigger type. I use it as a sanity check to ensure that my data does not contain missing triggers and that the participant completed the correct number of trials/blocks.\n\n```octave\n% nTrig = count_triggers(EEG)\n%\n%    Count the number of unique triggers contained in the EEG.event \n%    structure.\n%\n% In:\n%    EEG   - An EEGLAB data structure\n%\n% Out:\n%    nTrig - Cell array containing the unique trigger names and how many\n%            times they occur in the recording.\n\n% Author: Daniele Scanzi\n\nfunction nTrig = count_triggers(EEG)\n\n    % Check that event structure is in EEG structure\n    if ~isfield(EEG, \"event\")\n        error(\"Cannot find event structure. Is EEG an EEGLAB structure?\")\n    end\n    \n    % Find unique events\n    nTrig = unique({EEG.event.type})';\n    if isempty(nTrig)\n        error(\"Cannot find any events in the event structure. Do you need to load them?\")\n    end\n\n    % Create cell array storing name of event and their number\n    for iEvent = 1:size(nTrig,1)\n        nTrig{iEvent, 2} = sum(strcmp({EEG.event.type}, nTrig{iEvent, 1}));\n    end\n\nend\n```\n\n## Add extra trigger information\n\nThis function is useful if you have triggers represented as codes (eg. *T100*) and you would like to add their meaning in the EEG.event structure. However, you can add any other information.\n\n```octave\n% EEG = add_trigger_info(EEG, trigInfo, varargin)\n%\n%    Add extra information to the EEG.event structure. It is useful to add\n%    trigger information for each trigger. For instance, you can add the\n%    meaning of each trigger if trigger codes have been used.\n%\n% In:\n%    EEG      - An EEGLAB data structure\n%    trigInfo - Cell array of size NxM. N should reflect the number of\n%               triggers for which extra information should be added. M\n%               should reflect the nuber of extra information to add. M new\n%               columns will be added to the EEG.event structure. M must be\n%               at least 2, where the first column should contain the\n%               names of the triggers (one for each row) and the second\n%               column contains the information to add. For instance, if\n%               you have three triggers and you want to add their meaning,\n%               you could pass a cell array such as:\n%               {'T100' 'start_recording'; \n%                'T150' 'pause_recording';\n%                'T200' 'stop_recording'}\n%\n% Optional:\n%     fieldName - Cell array containing the names of the new columns to add\n%                 to the EEG.event structure. The cell array should have\n%                 size of 1xM, where M is the number of the extra\n%                 information columns to add. M must match the number of\n%                 columns of trigInfo. If no names are provided, the new\n%                 columns will be named 'X1', 'X2',..., 'XM'\n%\n% Out:\n%    EEG        - Modified copy of the EEG structure\n\n% Author: Daniele Scanzi\n\nfunction EEG = add_trigger_info(EEG, trigInfo, varargin)\n\n    p = inputParser;\n    \n    % Mandatory\n    addRequired(p, 'EEG', @isstruct);     % EEG structure\n    addRequired(p, 'trigInfo', @iscell);  % Cell array containing tirgger info\n    \n    % Optional\n    addParameter(p, 'fieldName', [], @iscell);         % Name/s to provide to the fields to add\n    \n    % Parse user input\n    parse(p, EEG, trigInfo, varargin{:});\n\n    EEG = p.Results.EEG;\n    triggInfo   = p.Results.trigInfo;\n    fieldName   = p.Results.fieldName;\n\n    %% Checks\n   \n   if size(trigInfo, 2) <= 1\n       error('triggerInfo should be a cell array with at least two columns: Trigger names - New field1 \\n');\n   end\n\n   % Create names for field if not provided, check otherwise\n   if isempty(fieldName)\n       fieldName = cell(size(trigInfo, 2) - 1, 1);\n       for iField = 1:( size(trigInfo, 2) - 1 )\n           fieldName{iField, 1} = strcat('X', num2str(iField));\n       end\n   else\n       if length(fieldName) ~= ( size(trigInfo, 2) - 1 )\n           error('fieldNames should match the number of new fields contained in trigInfo \\n');\n       end\n   end\n   \n   for iEvent = 1:length(EEG.event)\n       currentEvent       = EEG.event(iEvent).type;\n       currentTrigInfoIdx = find(strcmp(trigInfo(:, 1), currentEvent));\n\n       % Add info\n       for iInfo = 1:length(fieldName)\n           if isempty(currentTrigInfoIdx)\n               EEG.event(iEvent).(fieldName{iInfo}) = 'n/a';\n           else\n               EEG.event(iEvent).(fieldName{iInfo}) = trigInfo{currentTrigInfoIdx, iInfo+1};\n           end\n       end\n   end\nend\n\n```\n\n## Compute latencies with photosensor\n\nIn our current EEG setup, we have a [Brainproducts](https://www.brainproducts.com/) system where triggers are sent through a [triggerbox](https://www.brainproducts.com/solutions/triggerbox/). We also have a [photosensor](https://pressrelease.brainproducts.com/photosensor/), which allows us to detect with precision when a stimulus is presented on the screen. Unfortunately, we do not have the [StimTrack](https://www.brainproducts.com/solutions/stimtrak/) used to convert the photosensor data into triggers. So, we need to do this ourselves.\n\nThe photosensor data is stored as an extra channel in the EEG data. If the photosensor is set up to detect a switch from a dark to a light stimulus, then it creates a trace with a spike (NOTE: not a square wave) when the switch happens. The spike begins at the onset of the light stimulus and peaks just after that. \n\nI did not test this function with other systems, but I would assume it would work (grating that the photosensor records luminance and not just the change in luminance).\n\nBriefly, this function does the following:\n1. Detect the photosensor spikes onsets\n2. Add triggers at the detected onset latencies\n3. For each trigger, check whether there is an associated photosensor trigger, accounting for the fact that the photosensor could appear before or after the associated trigger. \n\nThe order of photosensor-trigger seems to depend on how the experiment is coded and reflects whether the trigger lags behind the stimulus or not. I'm still discussing this point with friends, but we don't have a conclusive explanation for this. Any insight on this is welcomed.\n\n```octave\n% [eventLatenciesInfo, EEG] = trigger_photo_latency(EEG, eventNames, varargin)\n%\n%         Align the recorded triggers to the onset times recorded by\n%         Brainproducts' photosensor. Conversion follows the procedure:\n%         1. Extract data from photosensor\n%         2. Find onset of spikes - spikes reflect changes in contrast\n%         3. Add found onsets to EEG.event structure in chronological order\n%         4. For eah trigger, find closest spike (within defined tolerance)\n%         5. Convert the original onset time of each trigger to its\n%            assciated spike onset time\n%\n% In:\n%    EEG        - An EEGLAB data structure\n%    eventNames - Cell array of strings represenitng the names of the\n%                 triggers to align\n%\n% Optional:\n%    photoTrigger       - Name to provide to the triggers representing the\n%                         photosensor event onsets. Default: 'photo'\n%    photoChannel       - Channel number (int) or channel name (string) of \n%                         the channel containing the photosensor data\n%    normalisePhotoData - Logical (true|false). Whether to normalise the \n%                         photosensor data prior to find the peaks. If true, \n%                         data is normalised in range [0,1]. Default: true\n%\n%    peakHeightThresh   - Minimum peak height for a photosensor spike to be\n%                         considered an event. This value is empirical and\n%                         it depends on multiple factors (eg. colour of the\n%                         photosensor stimulus). Can be useful to evoid \n%                         considering events changes in diplay contrast not\n%                         associated with the experiment (eg. experiment \n%                         window opening). Deafult: 0\n%    missedTrigTresh    - Maximum acceptable lag (in ms) between recorded \n%                         trigger and photosensor spike. If the lag is\n%                         higher than thism a warning is produced. This\n%                         often occurs if you try to align a trigger that\n%                         does not have an associated photosensor.\n%    modifyOriginal     - Logical (true|false). Whether to return a modified\n%                         copy of the EEG structure containin the\n%                         re-aligned events. Default: true\n%\n% Out:\n%    eventLatenciesInfo - Cell array containing delays information for each\n%                         trigger included in eventNames. Each row\n%                         represents a different trigger. Columns\n%                         represent: \n%                         1. Trigger name\n%                         2. Trigger idx in modified EEG.event structure\n%                         3. Array of delays (ms) for each trigger\n%                         4. Average delay (ms) for each trigger\n%    EEG                - Modified copy of the EEG structure where the \n%                         EEG.event structure now contains:\n%                         1. Photosensor events as triggers\n%                         2. Onset of triggers alligned with the\n%                            photosensor events\n\n% Author: Daniele Scanzi\n\nfunction [eventLatenciesInfo, EEG] = trigger_photo_latency(EEG, eventNames, varargin)\n    \n    % INPUTS\n    p = inputParser;\n    \n    % Mandatory\n    addRequired(p, 'EEG', @isstruct);      % EEG structure with EEG data\n    addRequired(p, 'eventNames', @iscellstr); % Signal matrix\n    \n    % Optional\n    addParameter(p, 'photoTrigger', 'photo', @ischar);       % Name of the trigger to add\n    addParameter(p, 'photoChannel', 64);                     % Channel containing the photosensor data\n    addParameter(p, 'normalisePhotoData', true, @islogical); % Whether to normalise the data or not\n    addParameter(p, 'peakHeightThresh', 0, @isnumeric);      % Minimum height to consider something a peak\n    addParameter(p, 'missedTrigTresh', 16, @isnumeric);      % Max delay (in ms) acceptable\n    addParameter(p, 'modifyOriginal', true, @islogical);     % Whether to modify the original EEG structure or not\n    \n    parse(p, EEG, eventNames, varargin{:});\n    \n    EEG                = p.Results.EEG;\n    eventNames         = p.Results.eventNames;\n    photoTrigger       = p.Results.photoTrigger;\n    photoChannel       = p.Results.photoChannel;\n    normalisePhotoData = p.Results.normalisePhotoData;\n    peakHeightThresh   = p.Results.peakHeightThresh;\n    missedTrigTresh    = p.Results.missedTrigTresh;\n    modifyOriginal     = p.Results.modifyOriginal;\n\n    %% MAIN FUNCTION\n\n    % Check that event structure is in EEG structure\n    if ~isfield(EEG, \"event\")\n        error(\"Cannot find event structure. Is EEG an EEGLAB structure?\")\n    end\n\n    % Check that provided events exist\n    for iEvent = 1:length(eventNames)\n        if ~any(strcmp({EEG.event.type}, eventNames{iEvent}))\n            error(\"Cannot find %s in EEG.event structure\", eventNames{iEvent})\n        end\n    end\n\n    % Check that data contains the channel requested\n    if isinteger(photoChannel)\n        if ~size(EEG.data, 1) < photoChannel\n            error(\"Channel %i out of bound of data size %i\", photoChannel, size(EEG.data, 1))\n        end\n    elseif ischar(photoChannel) || isstring(photoChannel)\n        if ~any(strcmp({EEG.chanlocs.labels}, photoChannel))\n            error(\"Channel %s not found\", photoChannel)\n        else\n            % find channel number and overwrite string\n            photoChannel = find(strcmp({EEG.chanlocs.labels}, photoChannel));\n        end\n    end\n\n    % The function should run even with epoched data, but this has not been\n    % tested yet. There are no many reasons for using this function with\n    % epoched data anyway\n    if ndims(EEG.data) > 2\n        warning(\"Function not tested with epoched data (or data with more \" + ...\n            \"than two dimensions in general\" )\n    end\n\n    % Extract photsensor data (account for possibility of data being\n    % epoched). Correct peaks so to find photosensor onset\n    photoData = EEG.data(photoChannel, :, :);\n    photoData = diff(photoData);\n    \n    if normalisePhotoData\n        photoData = normalize(photoData, 'range');\n    end\n\n    % Find peaKs\n    [~, peaksLocs] = findpeaks(photoData, 'MinPeakHeight', peakHeightThresh);\n\n    % Add peaks to the event structure data\n    fprintf(\"Adding photosensor events to EEG.event structure\")\n    % Add peaks to chanloc values\n    for iPeak = 1:length(peaksLocs)\n        EEG.event(end+1).latency = peaksLocs(iPeak);\n        EEG.event(end).type = photoTrigger;\n    end\n\n    % Reorder events by latency\n    EEG = eeg_checkset(EEG,'eventconsistency');\n\n    % First find triggers indices\n    eventLatenciesInfo = {length(eventNames), 4};\n    for iEvent = 1:length(eventNames)\n        eventLatenciesInfo{iEvent, 1} = eventNames{iEvent};\n        eventLatenciesInfo{iEvent, 2} = find(strcmp({EEG.event.type}, eventNames{iEvent}));\n    end\n    \n    % Compute event latencies finding the nearest photosensor event\n    for iEvent = 1:size(eventLatenciesInfo, 1)\n        % create arry to store latencies\n        currentLatencies = nan(length(eventLatenciesInfo{iEvent, 2}), 1);\n        for iTrig = 1:length(eventLatenciesInfo{iEvent, 2})\n\n            % Check previous event\n            previousTrigger = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)-1);\n            nextTrigger     = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)+1);\n            if strcmp({previousTrigger.type}, photoTrigger)\n                previousLatencyDiff = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency - EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)-1).latency;\n            else\n                % if there is no photosensor trigger before, set this diff\n                % tp -Inf\n                previousLatencyDiff = nan;\n            end\n\n            % Check next event\n            if strcmp({nextTrigger.type}, photoTrigger)\n                nextLatencyDiff = EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)+1).latency - EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency;\n            else\n                % if there is no photosensor trigger before, set this diff\n                % tp -Inf\n                nextLatencyDiff = nan;\n            end\n\n            % Find minimum between the two\n            [currentMin, minIdx] = min([previousLatencyDiff nextLatencyDiff]);\n            if  currentMin > missedTrigTresh\n                warning(\"Possible missing triggers around trigger number %i. Event not included in latency calculation \\n\", eventLatenciesInfo{iEvent, 2}(iTrig));\n                currentLatencies(iTrig) = nan;\n            else\n                currentLatencies(iTrig) = currentMin;\n            end\n            \n            % Modify the original dataset event structure if requested\n            if modifyOriginal\n                if minIdx == 1\n                    EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency = previousTrigger.latency;\n                elseif minIdx == 2\n                    EEG.event(eventLatenciesInfo{iEvent, 2}(iTrig)).latency = nextTrigger.latency;\n                end\n            end\n\n        end\n\n        % Compute average latency excluding missing triggers\n        currentLatencies = currentLatencies(~isnan(currentLatencies));\n        eventLatenciesInfo{iEvent, 3} = currentLatencies;\n        eventLatenciesInfo{iEvent, 4} = mean(currentLatencies);\n    end\n    EEG = eeg_checkset(EEG);\nend\n\n\n\n% Helper\nfunction isText(myVar)\n    isstring(myVar) || ischar(myVar);\nend\n```\n\n## GNU statement\n\n*This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.*\n \n*This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details (https://www.gnu.org/licenses).*\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"eeg_preprocessing_functions.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":{"dark":["cyborg","../../mystyles.scss"],"light":["cyborg","../../cyborg_light.scss"]},"title":"EEG preprocessing functions"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}