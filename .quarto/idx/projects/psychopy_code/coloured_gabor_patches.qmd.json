{"title":"Psychopy useful functions","markdown":{"yaml":{"title":"Psychopy useful functions"},"headingText":"Creating coloured gratings (pseudo-Gabor).","containsRefs":false,"markdown":"\n\nThe following document contains a collection of functions created to run experiments in Psychopy.\n\n\n``` python\nfrom psychopy import visual, event, monitors, tools\nfrom psychopy.visual import filters\nfrom psychopy.tools import monitorunittools as mut\nimport numpy as np\nimport math\nimport os\n\n###############################################################################\n#                                VARIABLES\n###############################################################################\n\nSAVE_IMAGE = True             #Set to true if you want to output an image\nDIFFERENT_BRIGHTNESS = True   #Should the stimuli have different luminance?\nSWITCH_SIDE = True            #Invert the left and right grating\nWHAT_TO_DRAW = \"right\"        #Either \"both\", \"left\" or \"rigth\"\n# Parameters for the gratings\nparam_stim = {\n    \"resolution\": 5,           #Size of the stimulus grating in deg (this will be coverted in pix later)\n    \"mask_resolution\": 2**11,  #Resolution of the mask used to render the gratings as circles (must be a power of 2)\n    \"ori_left\": 45,            #Orientation of the first grating\n    \"ori_right\": -45,          #Orientation of the second grating \n    \"pos_left\": (0, 0),        #Position of the first grating (0,0 is the center of the screen)\n    \"pos_right\": (0, 0),       #Position of the second grating (0,0 is the center of the screen)\n    \"cycles\": 4*5,             #Spatial frequency of the gratings. This should be resolution X cycles per deg\n    \"vergence_cycles\": 5,      #Spatial frequency of the gratings used to create the vergence patterns\n    \"vergence_sf\": 0.03,       #This value controls the number of gratings used in the vergence patterns (use values < 0.5)\n    \"alpha_left\": 1,\n    \"max_value_first\": -0.3 #Red: Psychopy [-0.0030, -1,-1], RGB [89,0,0], HSV[0,100,35]\n}\n\n# Screen and window parameters - for Psychopy\nparam_pc = {\n    \"resolution\": (1920, 1080),\n    \"width\": 34.2}\n\n# Directories and file names for the image output\nthis_dir = os.path.dirname(os.path.abspath(__file__))\nimage_name = \"red_single_03-1-1.png\"  #Name of the file to output at the end\n\n###############################################################################\n#                                   WINDOW\n###############################################################################\n\n# Create monitor and windows\nmon = monitors.Monitor(\n    name=\"desk_monitor\",\n    width=param_pc[\"width\"],\n    distance=57\n)\nmon.setSizePix = param_pc[\"resolution\"]\n\nwin = visual.Window(\n    size=param_pc[\"resolution\"],\n    monitor=mon,\n    units=\"pix\",\n    allowGUI=False,\n    screen=1,\n    fullscr=False,\n    color=(-1, -1, -1),\n    colorSpace='rgb',\n    blendMode='avg',\n    winType='pyglet',\n    useFBO=True)\n\n\n###############################################################################\n#                                  FROM DEG TO PIX\n###############################################################################\n\n# Convert to pix\nparam_stim[\"resolution\"] = int(mut.deg2pix(param_stim[\"resolution\"], mon))\n# Round pix to the closest power of 2. NOTE this works for \"low\" values but \n# cannot be generalized to high values (eg. 100000). However, here we work with \n# values in the 100 range (eg. 256 pix).\nparam_stim[\"resolution\"] = 2**round(math.log2(param_stim[\"resolution\"]))\n\n###############################################################################\n#                                    STIMULI\n# To create the gratings we start by creating a black texture defined as a \n# matrix of dimension [dim1, dim2, 3], where the three layers represent the RGB\n# colours. Then, we will replace the layer of the colour we are interested in \n# with a grating, which is a [dim1, dim2] array, conatining values from -1 to 1 \n# representing the intensity of the colour. Doing this will create a grating \n# stimulus of the desired colour.\n# For the red stimulusg, we are interested in manipulating its brightness. To do \n# so, we define a colour in HSV space and convert it into RGB (use tool online)\n# Then we modify the grating range, so that it goes from -1 (black) to N, where\n# N is the values obtained online\n###############################################################################\n\n# Switch side if requested\nif SWITCH_SIDE:\n    pos_left  = param_stim[\"pos_left\"]\n    pos_right = param_stim[\"pos_right\"]\n    param_stim[\"pos_left\"] = pos_right\n    param_stim[\"pos_right\"] = pos_left\n    \n# ---Coloured Gabors---#\n\n# Create a black texture for both stimuli...\ngrating_left = np.ones((param_stim[\"resolution\"], param_stim[\"resolution\"], 3)) * -1\ngrating_right = np.ones((param_stim[\"resolution\"], param_stim[\"resolution\"], 3)) * -1\n\n# GREEN --> For the green stimulus we simply overaly the grating to the G channel\ngrating_right[:, :, 1] = filters.makeGrating(res=param_stim[\"resolution\"],\n                                              ori=param_stim[\"ori_right\"],\n                                              cycles=param_stim[\"cycles\"],\n                                              gratType=\"sin\")\n\n\n\n# RED --> For the red stimulus we need to do some more work...\n\n# Create a grating\nsin_mask = filters.makeGrating(res=param_stim[\"resolution\"],\n                                            ori=param_stim[\"ori_left\"],\n                                            cycles=param_stim[\"cycles\"],\n                                            gratType=\"sin\")\n\n# If different luminance is requested\nif DIFFERENT_BRIGHTNESS:\n    # Scale only positive values to change the colour (RED) but not the black through the Rohan's transform\n    # NOTE: it's not a real transform...it was a tip from a friend\n    scale_factor = 0.5*(param_stim[\"max_value_first\"]+1)\n    sin_mask_scaled = scale_factor * (sin_mask + 1) - 1\n   \n    grating_left[:,:,0] = sin_mask_scaled\n# If no difference in brightness is required, apply the grating as above\nelse:\n    grating_left[:, :, 0] = sin_mask\n\n\n#---Vergence Gratings---#\n\n# Create a gray texture (Psychopy [0,0,0] is gray)...\ngrating_vergence = np.zeros((param_stim[\"resolution\"], param_stim[\"resolution\"], 3))\n\n#...then overimpose a grid on all the three RGB channels\ngrating_vergence[:, :, 0] = filters.makeGrating(res=param_stim[\"resolution\"],\n                                                cycles=param_stim[\"vergence_cycles\"],\n                                                ori=45,\n                                                gratType='sin')\ngrating_vergence[:, :, 1] = filters.makeGrating(res=param_stim[\"resolution\"],\n                                                cycles=param_stim[\"vergence_cycles\"],\n                                                ori=45,\n                                                gratType='sin')\ngrating_vergence[:, :, 2] = filters.makeGrating(res=param_stim[\"resolution\"],\n                                                cycles=param_stim[\"vergence_cycles\"],\n                                                ori=45,\n                                                gratType='sin')\n\n#---Circle Mask---#\n\n# Generate a nice smooth (at least almost) circle mask\nmask = filters.makeMask(matrixSize=param_stim[\"mask_resolution\"],\n                        shape=\"circle\")\n\n#---Generate Stimuli with Psychopy---#\n\n# left grating stimulus\nstim_left = visual.GratingStim(\n    name=\"stimL\",\n    win=win,\n    size=(param_stim[\"resolution\"], param_stim[\"resolution\"]),\n    pos=param_stim[\"pos_left\"],\n    tex=grating_left,\n    mask=mask,\n    units=\"pix\")\n# Right grating stimulus\nstim_right = visual.GratingStim(\n    name=\"stimR\",\n    win=win,\n    size=(param_stim[\"resolution\"], param_stim[\"resolution\"]),\n    pos=param_stim[\"pos_right\"],\n    tex=grating_right,\n    mask=mask,\n    units=\"pix\")\n# Left vergence pattern\nvergence_left = visual.GratingStim(\n    name=\"vergL\",\n    win=win,\n    size=(param_stim[\"resolution\"]+50, param_stim[\"resolution\"]+50),\n    pos=param_stim[\"pos_left\"],\n    tex=grating_vergence,\n    mask=mask,\n    units=\"pix\",\n    sf=param_stim[\"vergence_sf\"])\n# Right vergence pattern\nvergence_right = visual.GratingStim(\n    name=\"vergR\",\n    win=win,\n    size=(param_stim[\"resolution\"]+50, param_stim[\"resolution\"]+50),\n    pos=param_stim[\"pos_right\"],\n    tex=grating_vergence,\n    mask=mask,\n    units=\"pix\",\n    sf=param_stim[\"vergence_sf\"])\n\n# Left fixation dot\nfixation_left = visual.ShapeStim(\n    win=win,\n    name='polygon',\n    size=(param_stim[\"resolution\"]/50, param_stim[\"resolution\"]/50),\n    vertices='circle',\n    ori=0.0,\n    pos=param_stim[\"pos_left\"],\n    anchor='center',\n    lineWidth=1.0,\n    colorSpace='rgb',\n    lineColor='white',\n    fillColor='white',\n    opacity=None,\n    depth=0.0,\n    interpolate=True)\n\nfixation_right = visual.ShapeStim(\n    win=win,\n    name='polygon',\n    size=(param_stim[\"resolution\"]/50, param_stim[\"resolution\"]/50),\n    vertices='circle',\n    ori=0.0,\n    pos=param_stim[\"pos_right\"],\n    anchor='center',\n    lineWidth=1.0,\n    colorSpace='rgb',\n    lineColor='white',\n    fillColor='white',\n    opacity=None,\n    depth=0.0,\n    interpolate=True)\n\n\n###############################################################################\n#                                    DRAW\n###############################################################################\n\nif WHAT_TO_DRAW == \"both\":\n# Draw stimuli on buffer\n    vergence_left.draw()\n    vergence_right.draw()\n    stim_left.draw()\n    stim_right.draw()\n    fixation_left.draw()\n    fixation_right.draw()\nelif WHAT_TO_DRAW == \"left\":\n    vergence_left.draw()\n    stim_left.draw()\n    fixation_left.draw()\nelse:\n    vergence_right.draw()\n    stim_right.draw()\n    fixation_right.draw()\n\n# Present stimuli on the window\nwin.flip()\n# Save stimuli if requested\nif SAVE_IMAGE:\n    frame = win.getMovieFrame()\n    frame.save(os.path.join(this_dir, image_name))\n# Terminate when a key is pressed\nevent.waitKeys()\n# Close the Psychopy window\nwin.close()\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"coloured_gabor_patches.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":{"dark":["cyborg","../../mystyles.scss"],"light":["cyborg","../../cyborg_light.scss"]},"title":"Psychopy useful functions"},"extensions":{"book":{"multiFile":true}}}}}